<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>rusEFI Wiki Node Map</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/3.0.2/sigma.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.26.0/graphology.umd.min.js"></script>
		<script src="/nav.js"></script>
		<script type="module">
			import { bfsFromNode } from 'https://cdn.jsdelivr.net/npm/graphology-traversal@0.3.1/+esm'
			import { circular } from 'https://cdn.jsdelivr.net/npm/graphology-layout@0.6.1/+esm'
			Papa.parse("/map.csv", {
				download: true,
				header: true,
				delimiter: ",",
				complete: (results) => {
					var graph = new graphology.Graph();
					results.data.forEach((line) => {
						if (line.from != "" && line.to != "" && line.from != line.to) {
							if (!graph.hasNode(line.from)) {
								graph.addNode(line.from, {
									label: line.from,
									size: 3,
									color: "blue",
								});
							}
							if (line.to) {
								if (!graph.hasNode(line.to)) {
									graph.addNode(line.to, {
										label: line.to,
										size: 3,
										color: "blue",
									});
								}
								if (!graph.hasEdge(line.from, line.to)) {
									graph.addEdge(line.from, line.to);
								}
							}
						}
					});

					var distances = {};
					nav.forEach((page) => {
						bfsFromNode(graph, page, (node, _, depth) => {
							if (nav.indexOf(node) >= 0) {
								distances[node] = 1
							} else if (! (node in distances) || depth < distances[node]) {
								distances[node] = depth + 1;
							}
						});
					})

					let maxd = Math.max(...Object.values(distances));
					graph.forEachNode((node) => {
						if (! (node in distances) && nav.indexOf(node) < 0) {
							let depth = graph.degree(node) == 0 ? maxd + 2 : maxd + 1;
							distances[node] = depth;
						}
					});

					circular.assign(graph);
					
					const counts = Object.values(distances).reduce((acc, val) => {
						acc[val] = (acc[val] || 0) + 1;
						return acc;
					}, {});
					var nth = Object.assign({}, counts);
					Object.keys(distances).forEach((node) => {
						let level = 0;
						let angle = 0;
						level = distances[node];
						angle = (nth[level] / counts[level]) * Math.PI * 2;
						nth[level] -= 1;

						graph.setNodeAttribute(node, "x", Math.cos(angle) * level * 0.1);
						graph.setNodeAttribute(node, "y", Math.sin(angle) * level * 0.1);
					});

					const renderer = new Sigma(
						graph,
						document.getElementById("container"),
						{
							zIndex: true
						}
					);

					renderer.on("clickNode", (e) => {
						graph.forEachEdge((id, b, s, t) => {
							if (s == e.node) {
								graph.setEdgeAttribute(id, "color", "#F00");
								graph.setEdgeAttribute(id, "zIndex", "2");
							} else if (t == e.node) {
								graph.setEdgeAttribute(id, "color", "#0F0");
								graph.setEdgeAttribute(id, "zIndex", "1");
							} else {
								graph.setEdgeAttribute(id, "color", "#ccc");
								graph.setEdgeAttribute(id, "zIndex", "0");
							}
						});
					});
				},
			});

		</script>
	</head>
	<body>
		<style>
			html,
			body,
			#container {
					width: 100%;
					height: 100%;
					margin: 0;
					padding: 0;
					overflow: hidden;
			}
		</style>
		<div id="container"></div>
	</body>
</html>
